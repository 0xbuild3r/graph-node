initSidebarItems({"constant":[["BLOCK_NUMBER_MAX",""]],"enum":[["AttributeNames","Determines which columns should be selected in a table."],["ChildMultiplicity","How many children a parent can have when the child stores the id of the parent"],["EntityChange","Entity change events emitted by Store implementations."],["EntityChangeOperation","Operation types that lead to entity changes."],["EntityCollection","The base collections from which we are going to get entities for use in `EntityQuery`; the result of the query comes from applying the query’s filter and order etc. to the entities described in this collection. For a windowed collection order and range are applied to each individual window"],["EntityFilter","Supported types of store filters."],["EntityLink","How to select children for their parents depending on whether the child stores parent ids (`Direct`) or the parent stores child ids (`Parent`)"],["EntityModification","An entity operation that can be transacted into the store; as opposed to `EntityOperation`, we already know whether a `Set` should be an `Insert` or `Update`"],["EntityOp","A representation of entity operations that can be accumulated."],["EntityOperation","An entity operation that can be transacted into the store."],["EntityOrder","The order in which entities should be restored from a store."],["ParentLink","How to connect children to their parent when the child table does not store parent id’s"],["StoreError",""],["WindowAttribute","The attribute we want to window by in an `EntityWindow`. We have to distinguish between scalar and list attributes since we need to use different queries for them, and the JSONB storage scheme can not determine that by itself"]],"mod":[["__mock_MockChainStore",""],["__mock_MockChainStore_ChainStore",""],["__mock_MockStore",""]],"struct":[["DeploymentId","An internal identifer for the specific instance of a deployment. The identifier only has meaning in the context of a specific instance of graph-node. Only store code should ever construct or consume it; all other code passes it around as an opaque token."],["DeploymentLocator","A unique identifier for a deployment that specifies both its external identifier (`hash`) and its unique internal identifier (`id`) which ensures we are talking about a unique location for the deployment’s data in the store"],["EntityCache","A cache for entities from the store that provides the basic functionality needed for the store interactions in the host exports. This struct tracks how entities are modified, and caches all entities looked up from the store. The cache makes sure that (1) no entity appears in more than one operation (2) only entities that will actually be changed from what they are in the store are changed"],["EntityKey","Key by which an individual entity in the store can be accessed."],["EntityQuery","A query for entities in a store."],["EntityRange","How many entities to return, how many to skip etc."],["EntityType","The type name of an entity. This is the string that is used in the subgraph’s GraphQL schema as `type NAME @entity { .. }`"],["EntityWindow","Window results of an `EntityQuery` query along the parent’s id: the `order_by`, `order_direction`, and `range` of the query apply to entities that belong to the same parent. Only entities that belong to one of the parents listed in `ids` will be included in the query result."],["MockChainStore","Common trait for blockchain store implementations."],["MockChainStore_ChainStore",""],["MockStore",""],["ModificationsAndCache",""],["SUBSCRIPTION_THROTTLE_INTERVAL",""],["StoreEvent","The store emits `StoreEvents` to indicate that some entities have changed. For block-related data, at most one `StoreEvent` is emitted for each block that is processed. The `changes` vector contains the details of what changes were made, and to which entity."],["StoreEventStream","A `StoreEventStream` produces the `StoreEvents`. Various filters can be applied to it to reduce which and how many events are delivered by the stream."],["StoredDynamicDataSource",""]],"trait":[["BlockStore",""],["ChainStore","Common trait for blockchain store implementations."],["EthereumCallCache",""],["QueryStore","Store operations used when serving queries for a specific deployment"],["QueryStoreManager",""],["StatusStore","A view of the store that can provide information about the indexing status of any subgraph and any deployment"],["SubgraphStore","Common trait for store implementations."],["SubscriptionManager",""],["WritableStore",""]],"type":[["BlockNumber","The type we use for block numbers. This has to be a signed integer type since Postgres does not support unsigned integer types. But 2G ought to be enough for everybody"],["PoolWaitStats",""],["StoreEventStreamBox","A boxed `StoreEventStream`"]]});
initSidebarItems({"enum":[["JoinField","Describe a field that we join on. The distinction between scalar and list is important for generating the right filter, and handling results correctly"],["JoinRelation",""]],"fn":[["collect_fields","Collects fields of a selection set. The resulting map indicates for each response key from which types to fetch what fields to express the effect of fragment spreads"],["collect_fields_inner",""],["execute_field","Executes a field."],["execute_root_selection_set","Executes the root selection set of a query."],["execute_selection_set",""],["fetch","Query child entities for `parents` from the store. The `join` indicates in which child field to look for the parent’s id/join field. When `is_single` is `true`, there is at most one child per parent."],["filter_derived_fields","Removes all derived fields from a `AttributeNames` collection based on a referential `ObjectType`."],["is_root_node","We pass the root node of the result around as a vec of nodes, not as a single node so that we can use the same functions on interior node lists which are the result of querying the database. The root list consists of exactly one entry, and that entry has an empty (not even a `__typename`) entity."],["make_root_node",""],["node_list_as_value","Convert a list of nodes into a `q::Value::List` where each node has also been converted to a `q::Value`"],["run","Run the query in `ctx` in such a manner that we only perform one query per ‘level’ in the query. A query like `musicians { id bands { id } }` will perform two queries: one for musicians, and one for bands, regardless of how many musicians there are."]],"struct":[["ARG_FIRST",""],["ARG_ID",""],["ARG_SKIP",""],["CollectedAttributeNames",""],["CollectedResponseKey","If the top-level selection is on an object, there will be a single entry in `obj_types` with all the collected fields."],["DISABLE_EXPERIMENTAL_FEATURE_SELECT_BY_SPECIFIC_ATTRIBUTE_NAMES","Setting this environment variable to any value will enable the experimental feature “Select by Specific Attributes”."],["Join","Encapsulate how we should join a list of parent entities with a list of child entities."],["JoinCond",""],["Node","Intermediate data structure to hold the results of prefetching entities and their nested associations. For each association of `entity`, `children` has an entry mapping the response key to the list of nodes."],["ObjectCondition","An `ObjectType` with `Hash` and `Eq` derived from the name."]],"trait":[["ValueExt",""]],"type":[["AttributeNamesByObjectType","Represents a finished column collection operation, mapping each object type to the final set of selected SQL columns."],["GroupedFieldSet",""]]});
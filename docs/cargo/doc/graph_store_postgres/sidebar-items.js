initSidebarItems({"fn":[["register_jobs",""]],"mod":[["advisory_lock","Helpers for using advisory locks. We centralize all use of these locks in this module to make it easier to see what they are used for."],["block_range",""],["block_store",""],["catalog",""],["chain_head_listener",""],["chain_store",""],["command_support","This module is only meant to support command line tooling. It must not be used in ‘normal’ graph-node code"],["connection_pool",""],["copy","This module if repsonsible for copying the data of an existing subgraph `src` to a new subgraph `dst`. The copy is done in batches so that copying does not cause long-running transactions since they lead to table bloat in the rest of the system."],["deployment","Utilities for dealing with deployment metadata. Any connection passed into these methods must be for the shard that holds the actual deployment data and metadata"],["deployment_store",""],["detail","Queries to support the index node API"],["dynds","SQL queries to load dynamic data sources"],["functions",""],["jobs","Jobs for database maintenance"],["jsonb",""],["layout_for_tests",""],["notification_listener",""],["primary","Utilities for dealing with subgraph metadata that resides in the primary shard. Anything in this module can only be used with a database connection for the primary shard."],["query_store",""],["relational","Support for storing the entities of a subgraph in a relational schema, i.e., one where each entity type gets its own table, and the table structure follows the structure of the GraphQL type, using the native SQL types that most appropriately map to the corresponding GraphQL types"],["relational_queries",""],["sql_value",""],["store",""],["store_events",""],["subgraph_store",""],["unused","Tools for managing unused deployments"]],"struct":[["BlockStore","The store that chains use to maintain their state and cache often used data from a chain. The `BlockStore` maintains information about all configured chains, and serves as a directory of chains, whereas the [ChainStore] manages chain-specific data. The `BlockStore` is sharded so that each chain can use, depending on configuration, a separate database. Regardless of configuration, the data for each chain is stored in its own database namespace, though for historical reasons, the code also deals with a shared table for the block and call cache for chains in the `public` namespace."],["ChainHeadUpdateListener",""],["ChainStore",""],["DeploymentDetail",""],["PRIMARY_SHARD","The name of the primary shard that contains all instance-wide data"],["Shard","The name of a database shard; valid names must match `[a-z0-9_]+`"],["Store","The overall store of the system, consisting of a [SubgraphStore] and a [BlockStore], each of which multiplex across multiple database shards. The `SubgraphStore` is responsible for storing all data and metadata related to individual subgraphs, and the `BlockStore` does the same for data belonging to the chains that are being processed."],["SubgraphStore","Multiplex store operations on subgraphs and deployments between a primary and any number of additional storage shards. The primary contains information about named subgraphs, and how the underlying deployments are spread across shards, while the actual deployment data and metadata is stored in the shards.  Depending on the configuration, the database for the primary and for the shards can be the same database, in which case they are all backed by one connection pool, or separate databases in the same Postgres cluster, or entirely separate clusters. Details of how to configure shards can be found in this document"],["SubscriptionManager","Manage subscriptions to the `StoreEvent` stream. Keep a list of currently active subscribers and forward new events to each of them"],["UnusedDeployment",""]],"trait":[["DeploymentPlacer","Decide where a new deployment should be placed based on the subgraph name and the network it is indexing. If the deployment can be placed, returns the name of the database shard for the deployment and the names of the indexers that should index it. The deployment should then be assigned to one of the returned indexers."]]});
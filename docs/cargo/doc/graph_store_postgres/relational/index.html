<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Support for storing the entities of a subgraph in a relational schema, i.e., one where each entity type gets its own table, and the table structure follows the structure of the GraphQL type, using the native SQL types that most appropriately map to the corresponding GraphQL types"><meta name="keywords" content="rust, rustlang, rust-lang, relational"><title>graph_store_postgres::relational - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../graph_store_postgres/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Module relational</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class="location"><a href="../index.html">graph_store_postgres</a></p><div id="sidebar-vars" data-name="relational" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">graph_store_postgres</a>::<wbr><a class="mod" href="">relational</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/graph_store_postgres/relational.rs.html#1-2038" title="goto source code">[src]</a></span></h1><div class="docblock"><p>Support for storing the entities of a subgraph in a relational schema,
i.e., one where each entity type gets its own table, and the table
structure follows the structure of the GraphQL type, using the
native SQL types that most appropriately map to the corresponding
GraphQL types</p>
<p>The pivotal struct in this module is the <code>Layout</code> which handles all the
information about mapping a GraphQL schema to database tables</p>
</div><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use crate::catalog::<a class="struct" href="../../graph_store_postgres/catalog/struct.Catalog.html" title="struct graph_store_postgres::catalog::Catalog">Catalog</a>;</code></td></tr></table><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.ACCOUNT_TABLES.html" title="graph_store_postgres::relational::ACCOUNT_TABLES struct">ACCOUNT_TABLES</a></td><td class="docblock-short"><p>Deprecated; use ‘graphman stats account-like’ instead. A list of
fully qualified table names that contain entities that are like
accounts in that they have a relatively small number of entities,
with a large number of change for each entity. It is useful to treat
such tables special in queries by changing the clause that selects
for a specific block range in a way that makes the BRIN index on
block_range usable</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.CacheEntry.html" title="graph_store_postgres::relational::CacheEntry struct">CacheEntry</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.Column.html" title="graph_store_postgres::relational::Column struct">Column</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.EnumType.html" title="graph_store_postgres::relational::EnumType struct">EnumType</a></td><td class="docblock-short"><p>A user-defined enum</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Layout.html" title="graph_store_postgres::relational::Layout struct">Layout</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="struct" href="struct.LayoutCache.html" title="graph_store_postgres::relational::LayoutCache struct">LayoutCache</a></td><td class="docblock-short"><p>Cache layouts for some time and refresh them when they expire.
Refreshing happens one at a time, and the cache makes sure we minimize
blocking while a refresh happens, favoring using an expired layout over
a refreshed one.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.STATEMENT_TIMEOUT.html" title="graph_store_postgres::relational::STATEMENT_TIMEOUT struct">STATEMENT_TIMEOUT</a></td><td class="docblock-short"><p><code>GRAPH_SQL_STATEMENT_TIMEOUT</code> is the timeout for queries in seconds.
If it is not set, no statement timeout will be enforced. The statement
timeout is local, i.e., can only be used within a transaction and
will be cleared at the end of the transaction</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.SqlName.html" title="graph_store_postgres::relational::SqlName struct">SqlName</a></td><td class="docblock-short"><p>A string we use as a SQL name for a table or column. The important thing
is that SQL names are snake cased. Using this type makes it easier to
spot cases where we use a GraphQL name like ‘bigThing’ when we should
really use the SQL version ‘big_thing’</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Table.html" title="graph_store_postgres::relational::Table struct">Table</a></td><td class="docblock-short"></td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.ColumnType.html" title="graph_store_postgres::relational::ColumnType enum">ColumnType</a></td><td class="docblock-short"><p>This is almost the same as graph::data::store::ValueType, but without
ID and List; with this type, we only care about scalar types that directly
correspond to Postgres scalar types</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.IdType.html" title="graph_store_postgres::relational::IdType enum">IdType</a></td><td class="docblock-short"><p>The SQL type to use for GraphQL ID properties. We support
strings and byte arrays</p>
</td></tr></table><h2 id="constants" class="section-header"><a href="#constants">Constants</a></h2>
<table><tr class="module-item"><td><a class="constant" href="constant.DELETE_OPERATION_CHUNK_SIZE.html" title="graph_store_postgres::relational::DELETE_OPERATION_CHUNK_SIZE constant">DELETE_OPERATION_CHUNK_SIZE</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.POSTGRES_MAX_PARAMETERS.html" title="graph_store_postgres::relational::POSTGRES_MAX_PARAMETERS constant">POSTGRES_MAX_PARAMETERS</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="constant" href="constant.PRIMARY_KEY_COLUMN.html" title="graph_store_postgres::relational::PRIMARY_KEY_COLUMN constant">PRIMARY_KEY_COLUMN</a></td><td class="docblock-short"><p>The name for the primary key column of a table; hardcoded for now</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant.STRING_PREFIX_SIZE.html" title="graph_store_postgres::relational::STRING_PREFIX_SIZE constant">STRING_PREFIX_SIZE</a></td><td class="docblock-short"><p>The size of string prefixes that we index. This is chosen so that we
will index strings that people will do string comparisons like
<code>=</code> or <code>!=</code> on; if text longer than this is stored in a String attribute
it is highly unlikely that they will be used for exact string operations.
This also makes sure that we do not put strings into a BTree index that’s
bigger than Postgres’ limit on such strings which is about 2k</p>
</td></tr><tr class="module-item"><td><a class="constant" href="constant.VID_COLUMN.html" title="graph_store_postgres::relational::VID_COLUMN constant">VID_COLUMN</a></td><td class="docblock-short"><p>We give every version of every entity in our tables, i.e., every row, a
synthetic primary key. This is the name of the column we use.</p>
</td></tr></table><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.is_object_type.html" title="graph_store_postgres::relational::is_object_type fn">is_object_type</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.named_type.html" title="graph_store_postgres::relational::named_type fn">named_type</a></td><td class="docblock-short"><p>Return the enclosed named type for a field type, i.e., the type after
stripping List and NonNull.</p>
</td></tr></table><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<table><tr class="module-item"><td><a class="type" href="type.EnumMap.html" title="graph_store_postgres::relational::EnumMap type">EnumMap</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="type" href="type.IdTypeMap.html" title="graph_store_postgres::relational::IdTypeMap type">IdTypeMap</a></td><td class="docblock-short"></td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="graph_store_postgres" data-search-js="../../search-index.js"></div>
    <script src="../../main.js"></script></body></html>
initSidebarItems({"enum":[["SubgraphHealth",""]],"fn":[["block_ptr",""],["check_health","Checks if the subgraph is healthy or unhealthy as of the given block, or the subgraph latest block if `None`, based on the presence of non-fatal errors. Has no effect on failed subgraphs."],["convert_to_u32",""],["copy_errors","Copy the dynamic data sources for `src` to `dst`. All data sources that were created up to and including `target_block` will be copied."],["create_deployment",""],["drop_metadata",""],["drop_schema","Drop the schema `namespace`. This deletes all data for the subgraph, and can not be reversed. It does not remove any of the metadata in the `subgraphs` schema for the deployment"],["error_count",""],["exists","Returns `true` if the deployment (as identified by `site.id`)"],["exists_and_synced","Returns `true` if the deployment `id` exists and is synced"],["fail",""],["features",""],["forward_block_ptr",""],["graft","Look up the graft point for the given subgraph in the database and return it. If `pending_only` is `true`, only return `Some(_)` if the deployment has not progressed past the graft point, i.e., data has not been copied for the graft"],["graft_pending","Look up the graft point for the given subgraph in the database and return it. Returns `None` if the deployment does not have a graft or if the subgraph has already progress past the graft point, indicating that the data copying for grafting has been performed"],["graft_point","Look up the graft point for the given subgraph in the database and return it. Returns `None` if the deployment does not have a graft"],["has_non_fatal_errors","If `block` is `None`, assumes the latest block."],["insert_subgraph_error",""],["insert_subgraph_errors","Insert the errors and check if the subgraph needs to be set as unhealthy."],["latest_as_block_number","Translate `latest` into a `BlockNumber`. If `latest` is `None` or does not represent an `i32`, return an error"],["manifest_info",""],["revert_block_ptr",""],["revert_subgraph_errors","Reverts the errors and updates the subgraph health if necessary."],["schema",""],["set_entity_count","Set the deploymentâ€™s entity count to whatever `full_count_query` produces"],["set_synced","Mark the deployment `id` as synced"],["state",""],["unfail","Clear the `SubgraphHealth::Failed` status of a subgraph and mark it as healthy or unhealthy depending on whether it also had non-fatal errors"],["update_entity_count",""]],"mod":[["db_enum_impl_SubgraphHealth",""],["graph_node_versions",""],["subgraph_deployment",""],["subgraph_error",""],["subgraph_manifest",""]]});
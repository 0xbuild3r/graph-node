initSidebarItems({"constant":[["CONN_POOL_SIZE",""],["NETWORK_NAME",""],["NETWORK_VERSION",""]],"fn":[["all_shards",""],["build_store",""],["create_subgraph",""],["create_test_subgraph",""],["deployment_state",""],["execute_subgraph_query","Run a GraphQL query against the `STORE`"],["execute_subgraph_query_internal",""],["execute_subgraph_query_with_complexity",""],["execute_subgraph_query_with_deadline",""],["insert_ens_name",""],["insert_entities",""],["place",""],["primary_connection",""],["remove_subgraph",""],["remove_subgraphs",""],["revert_block",""],["run_test_sequentially","Run the `test` after performing `setup`. The result of `setup` is passed into `test`. All tests using `run_test_sequentially` are run in sequence, never in parallel. The `test` is passed a `Store`, but it is permissible for tests to access the global `STORE` from this module, too."],["run_test_with_conn","Run a test with a connection into the primary database, not a full store"],["store_is_sharded",""],["tap_store_events","Tap into store events sent when running `f` and return those events. This intercepts `StoreEvent` when they are sent and therefore does not require the delicate timing that actually listening to events in the database requires. Of course, this does not test that events that are sent are actually received by anything, but makes ensuring that the right events get sent much more convenient than trying to receive them"],["transact_entities_and_dynamic_data_sources",""],["transact_entity_operations","Convenience to transact EntityOperation instead of EntityModification"],["transact_errors",""]],"struct":[["BLOCKS",""],["BLOCK_ONE",""],["BLOCK_STORE",""],["CONFIG",""],["GENESIS_PTR",""],["LOAD_MANAGER",""],["LOGGER",""],["NODE_ID",""],["PRIMARY_POOL",""],["SEQ_LOCK",""],["STORE",""],["STORE_POOL_CONFIG",""],["STORE_RUNTIME",""],["SUBGRAPH_STORE",""],["SUBSCRIPTION_MANAGER",""],["Store","The overall store of the system, consisting of a [SubgraphStore] and a [BlockStore], each of which multiplex across multiple database shards. The `SubgraphStore` is responsible for storing all data and metadata related to individual subgraphs, and the `BlockStore` does the same for data belonging to the chains that are being processed."]]});
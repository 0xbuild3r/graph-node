initSidebarItems({"enum":[["Array","Wrapper of Array for multiple AssemblyScript versions. It just delegates its method calls to the correct mappings apiVersion."],["ArrayBuffer","! Rust types that have with a direct correspondence to an Asc class, ! with their `AscType` implementations. Wrapper of ArrayBuffer for multiple AssemblyScript versions. It just delegates its method calls to the correct mappings apiVersion."],["AscString","Wrapper of String for multiple AssemblyScript versions. It just delegates its method calls to the correct mappings apiVersion."],["EthereumValueKind",""],["JsonValueKind",""],["LogLevel",""],["StoreValueKind",""],["TypedArray","Wrapper of TypedArray for multiple AssemblyScript versions. It just delegates its method calls to the correct mappings apiVersion."]],"struct":[["AscBigDecimal",""],["AscEnum","In Asc, we represent a Rust enum as a discriminant `kind: D`, which is an Asc enum so in Rust it’s a `#[repr(u32)]` enum, plus an arbitrary `AscValue` payload."],["AscResult",""],["AscTypedMap",""],["AscTypedMapEntry",""],["AscWrapped",""],["EnumPayload","Represents any `AscValue` since they all fit in 64 bits."]],"type":[["AscAddress",""],["AscBigInt","Big ints are represented using signed number representation. Note: This differs from how U256 and U128 are represented (they use two’s complement). So whenever we convert between them, we need to make sure we handle signed and unsigned cases correctly."],["AscEntity",""],["AscEnumArray",""],["AscH160",""],["AscJson",""],["AscTypedMapEntryArray",""],["Uint8Array",""]]});
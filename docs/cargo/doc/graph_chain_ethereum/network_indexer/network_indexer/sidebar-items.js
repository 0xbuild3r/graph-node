initSidebarItems({"enum":[["AfterAddBlock","The states that the `AddBlock` state can transition to."],["AfterEnsureSubgraph","The states that the `EnsureSubgraph` state can transition to."],["AfterLoadLocalHead","The states that the `LoadLocalHead` state can transition to."],["AfterPollChainHead","The states that the `PollChainHead` state can transition to."],["AfterProcessBlocks","The states that the `ProcessBlocks` state can transition to."],["AfterRevertLocalHead","The states that the `RevertLocalHead` state can transition to."],["AfterStart","The states that the `Start` state can transition to."],["AfterVetBlock","The states that the `VetBlock` state can transition to."],["NetworkIndexerEvent","Events emitted by the network tracer."],["StateMachine","State machine that handles block fetching and block reorganizations."],["StateMachineStates",""]],"fn":[["__smf_quiet_warnings_for_state_machine_future",""],["ensure_subgraph",""],["fetch_block_and_ommers_by_number",""],["fetch_blocks",""],["fetch_ommers",""],["load_local_head",""],["load_parent_block_from_store",""],["poll_chain_head",""],["revert_local_head",""],["send_event",""],["update_chain_and_local_head_metrics","Helpers for metrics"],["write_block",""]],"struct":[["AddBlock","This state waits until a block has been written and an event for it has been sent out. After that, the indexer continues processing the next block. If anything goes wrong at this point, it’s back to re-evaluating the chain head and fetching (potentially) different blocks for indexing."],["Context","Network tracer implementation. Context for the network tracer."],["EnsureSubgraph","This state ensures that the network subgraph that stores the indexed data exists, and creates it if necessary."],["Failed","State for fatal errors that cause the indexing to terminate. This should almost never happen. If it does, it should cause the entire node to crash and restart."],["LoadLocalHead","This state waits until the local head block has been loaded from the store. It then moves on to polling the chain head block."],["NetworkIndexer",""],["PollChainHead","This state waits until the chain head block has been polled successfully."],["ProcessBlocks","This state takes the next block from the stream. If the stream is exhausted, it transitions back to polling the chain head block and deciding on the next chunk of blocks to fetch. If there is still a block to read from the stream, it’s passed on to vetting for validation and reorg checking."],["Ready","This is unused, the indexing never ends."],["RevertLocalHead","This state reverts the local head, moving the local indexed data back by one block."],["Start","The indexer start in an empty state and immediately moves on to ensuring that the network subgraph exists."],["StateMachineFuture",""],["VetBlock","This state vets incoming blocks with regards to two aspects:"]],"trait":[["PollStateMachine",""]],"type":[["AddBlockFuture",""],["BlockFuture",""],["BlockPointerFuture",""],["BlockStream",""],["ChainHeadFuture",""],["EnsureSubgraphFuture","Terminology used in this component:"],["LocalHeadFuture",""],["OmmersFuture",""],["RevertLocalHeadFuture",""],["SendEventFuture",""]]});
initSidebarItems({"fn":[["blocks_with_triggers","Returns blocks with triggers, corresponding to the specified range and filters. If a block contains no triggers, there may be no corresponding item in the stream. However the `to` block will always be present, even if triggers are empty."],["fetch_receipt_from_ethereum_client",""],["filter_call_triggers_from_unsuccessful_transactions",""],["get_calls",""],["parse_block_triggers",""],["parse_call_triggers",""],["parse_log_triggers",""]],"struct":[["BLOCK_BATCH_SIZE",""],["ETH_CALL_GAS","Gas limit for `eth_call`. The value of 25_000_000 is a protocol-wide parameter so this should be changed only for debugging purposes and never on an indexer in the network. The value of 25_000_000 was chosen because it is the Geth default https://github.com/ethereum/go-ethereum/blob/54c0d573d75ab9baa239db3f071d6cb4d1ec6aad/eth/ethconfig/config.go#L86. It is not safe to set something higher because Geth will silently override the gas limit with the default. This means that we do not support indexing against a Geth node with `RPCGasCap` set below 25 million."],["EthereumAdapter",""],["JSON_RPC_TIMEOUT","This should not be too large that it causes requests to timeout without us catching it, nor too small that it causes us to timeout requests that would’ve succeeded. We’ve seen successful `eth_getLogs` requests take over 120 seconds."],["MAX_EVENT_ONLY_RANGE","Maximum range size for `eth.getLogs` requests that dont filter on contract address, only event signature, and are therefore expensive."],["REQUEST_RETRIES","This is used for requests that will not fail the subgraph if the limit is reached, but will simply restart the syncing step, so it can be low. This limit guards against scenarios such as requesting a block hash that has been reorged."],["TRACE_STREAM_STEP_SIZE",""]]});
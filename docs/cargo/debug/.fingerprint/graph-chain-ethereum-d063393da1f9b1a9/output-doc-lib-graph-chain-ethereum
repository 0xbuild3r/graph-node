{"message":"could not parse code block as Rust code","code":null,"level":"warning","spans":[{"file_name":"chain/ethereum/src/network_indexer/network_indexer.rs","byte_start":18723,"byte_end":18814,"line_start":547,"line_end":551,"column_start":11,"column_end":14,"is_primary":true,"text":[{"text":"    ///   ```ignore","highlight_start":11,"highlight_end":20},{"text":"    ///   a---b---c---x","highlight_start":1,"highlight_end":24},{"text":"    ///       \\","highlight_start":1,"highlight_end":16},{"text":"    ///        +--d---e---f","highlight_start":1,"highlight_end":28},{"text":"    ///   ```","highlight_start":1,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"error from rustc: unknown start of token: \\","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`ignore` code blocks require valid Rust code for syntax highlighting. Mark blocks that do not contain Rust code as text","code":null,"level":"help","spans":[{"file_name":"chain/ethereum/src/network_indexer/network_indexer.rs","byte_start":18723,"byte_end":18726,"line_start":547,"line_end":547,"column_start":11,"column_end":14,"is_primary":true,"text":[{"text":"    ///   ```ignore","highlight_start":11,"highlight_end":14}],"label":null,"suggested_replacement":"```text,","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: could not parse code block as Rust code\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mchain/ethereum/src/network_indexer/network_indexer.rs:547:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m547\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    ///   ```ignore\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33m___________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m548\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///   a---b---c---x\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m549\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///       \\\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m550\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///        +--d---e---f\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m551\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///   ```\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|_____________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: error from rustc: unknown start of token: \\\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: `ignore` code blocks require valid Rust code for syntax highlighting. Mark blocks that do not contain Rust code as text\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m547\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    ///   ```text,ignore\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^\u001b[0m\n\n"}
{"message":"doc comment contains an invalid Rust code block","code":null,"level":"warning","spans":[{"file_name":"chain/ethereum/src/network_indexer/network_indexer.rs","byte_start":17924,"byte_end":20117,"line_start":529,"line_end":574,"column_start":5,"column_end":65,"is_primary":true,"text":[{"text":"    /// This state vets incoming blocks with regards to two aspects:","highlight_start":5,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// 1. Does the block have a number and hash? This is a requirement for","highlight_start":1,"highlight_end":76},{"text":"    ///    indexing to continue. If not, the indexer re-evaluates the chain","highlight_start":1,"highlight_end":76},{"text":"    ///    head and starts over.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// 2. Is the block the successor of the local head block? If yes, move","highlight_start":1,"highlight_end":76},{"text":"    ///    on to indexing this block. If not, we have a reorg.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Notes on the reorg handling:","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///   By checking parent/child succession, we ensure that there are no gaps","highlight_start":1,"highlight_end":80},{"text":"    ///   in the indexed data (class mathematical induction). So if the local","highlight_start":1,"highlight_end":78},{"text":"    ///   head is `x` and a block `f` comes in that is not a successor/child, it","highlight_start":1,"highlight_end":81},{"text":"    ///   must be on a different version/fork of the chain.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///   E.g.:","highlight_start":1,"highlight_end":16},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///   ```ignore","highlight_start":1,"highlight_end":20},{"text":"    ///   a---b---c---x","highlight_start":1,"highlight_end":24},{"text":"    ///       \\","highlight_start":1,"highlight_end":16},{"text":"    ///        +--d---e---f","highlight_start":1,"highlight_end":28},{"text":"    ///   ```","highlight_start":1,"highlight_end":14},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///   In that case we need to do the following:","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///   1. Find the common ancestor of `x` and `f`, which is the block after","highlight_start":1,"highlight_end":79},{"text":"    ///      which the two versions diverged (in the above example: `b`).","highlight_start":1,"highlight_end":74},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///   2. Collect old blocks betweeen the common ancestor and (including)","highlight_start":1,"highlight_end":77},{"text":"    ///      the local head that need to be reverted (in the above example:","highlight_start":1,"highlight_end":76},{"text":"    ///      `c`, `x`).","highlight_start":1,"highlight_end":24},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///   3. Fetch new blocks between the common ancestor and (including) `f`","highlight_start":1,"highlight_end":78},{"text":"    ///      that are to be inserted instead of the old blocks in order to","highlight_start":1,"highlight_end":75},{"text":"    ///      make the incoming block (`f`) the local head (in the above","highlight_start":1,"highlight_end":72},{"text":"    ///      example: `d`, `e`, `f`).","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///   We don't actually do all of the above explicitly. What we do instead","highlight_start":1,"highlight_end":79},{"text":"    ///   is that when we encounter a block that requires a reorg, we revert the","highlight_start":1,"highlight_end":81},{"text":"    ///   local head, moving back by one block in the indexed data. We then poll","highlight_start":1,"highlight_end":81},{"text":"    ///   the chain head again, fetch up to 100 blocks, vet the next block","highlight_start":1,"highlight_end":75},{"text":"    ///   again, and see if we have reverted back to the common ancestor yet. If","highlight_start":1,"highlight_end":81},{"text":"    ///   we have, we process the next block. If we haven't, we repeat reverting","highlight_start":1,"highlight_end":81},{"text":"    ///   the local head. Ultimately, this will take us back to the common","highlight_start":1,"highlight_end":75},{"text":"    ///   ancestor, and at that point we can move forward again.","highlight_start":1,"highlight_end":65}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"error from rustc: unknown start of token: \\","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: doc comment contains an invalid Rust code block\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mchain/ethereum/src/network_indexer/network_indexer.rs:529:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m529\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// This state vets incoming blocks with regards to two aspects:\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m530\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m531\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// 1. Does the block have a number and hash? This is a requirement for\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m532\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///    indexing to continue. If not, the indexer re-evaluates the chain\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m573\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///   the local head. Ultimately, this will take us back to the common\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m574\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///   ancestor, and at that point we can move forward again.\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[33m|________________________________________________________________^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: error from rustc: unknown start of token: \\\u001b[0m\n\n"}
{"message":"2 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 2 warnings emitted\u001b[0m\n\n"}
